CPU: Apple M1
OS: macOS
Date (UTC): 2025-12-31 00:00:00 UTC+0000
------------------------
========================================================================
Fused vs Unpacked Ternary Computation Benchmark
HyperFold Technologies UK Ltd.
========================================================================

Configuration:
  Matrix Size:  4096 × 4096
  Total Weights: 16777216
  Sparsity:     50%
  Iterations:   50

Memory Footprint:
  8-bit representation: 16384 KB
  2-bit representation: 4096 KB (75.0% reduction)

========================================================================
TEST 1: BASELINE (8-bit Standard)
========================================================================
Method: 8-bit int8_t -> standard integer multiplication
Running...
Total Time:     2808.77 ms
Time per Iter:  56.175 ms
Throughput:     0.60 GFLOPS

========================================================================
TEST 2: 2-BIT WITH UNPACKING (Decode Then Compute)
========================================================================
Method: 2-bit packed -> unpack to array -> standard multiplication
Running...
Total Time:     3290.70 ms
Time per Iter:  65.814 ms
Throughput:     0.51 GFLOPS
vs Baseline:    0.85x

========================================================================
TEST 3: FUSED KERNEL (2-bit Packed + Fused Decode-Compute)
========================================================================
Method: 2-bit packed -> direct computation without full unpacking
Optimizations:
  1. 2-bit packed encoding (75% memory reduction)
  2. Fused decode-compute (no temporary array)
Running...
Total Time:     2590.21 ms
Time per Iter:  51.804 ms
Throughput:     0.65 GFLOPS
vs Baseline:    1.08x
vs Unpacked:    1.27x

========================================================================
VERIFICATION (Tests 1-3)
========================================================================
✓ All outputs match (within epsilon=1e-3)

========================================================================
TEST 4: FUSED + SPARSE CSR (All Three Optimizations)
========================================================================
Testing with 70% sparsity to demonstrate CSR advantage...
  Sparsity: 70%
  Sparse CSR memory: 15584 KB (380.5% of 2-bit dense)
  Non-zero packed bytes: 3188472 / 4194304 (24.0% reduction)

Optimizations:
  1. 2-bit packed encoding (75% memory reduction)
  2. Fused decode-compute (no temporary array)
  3. Sparse CSR format (skip zero-only packed bytes)
Running...
Total Time:     1558.58 ms
Time per Iter:  31.172 ms
Throughput:     1.08 GFLOPS
vs Baseline:    1.80x
vs Test 3:      1.66x

========================================================================
SUMMARY
========================================================================

Method                         |    Time (ms) |  Memory (KB) |      Speedup |     GFLOPS
-------------------------------------------------------------------------------------
Test 1: Baseline (8-bit)       |      2808.77 |        16384 |       1.00× |       0.60
Test 2: 2-bit Unpacked         |      3290.70 |         4096 |         0.85x |       0.51
Test 3: Fused (2-bit+Fusion)   |      2590.21 |         4096 |         1.08x |       0.65
Test 4: Fused+CSR (70%% sparse) |      1558.58 |        15584 |         1.80x |       1.08

Key Comparisons:
  Test 3 vs Test 2 (Fusion advantage):    1.27x speedup
  Test 4 vs Test 3 (CSR advantage):       1.66x speedup
  Test 4 vs Baseline (Combined):          1.80x speedup

========================================================================
CONCLUSION
========================================================================

✓ THREE OPTIMIZATION PRINCIPLES DEMONSTRATED

1. FUSION ADVANTAGE (Test 3 vs Test 2): 1.27x
   Fused decode-compute eliminates unpacking overhead

2. SPARSE CSR ADVANTAGE (Test 4 vs Test 3): 1.66x
   At 70% sparsity, CSR format skips zero-only packed bytes

3. COMBINED ARCHITECTURE (Test 4 vs Baseline): 1.80x
   All three optimizations working together:
   - 2-bit packed encoding (75% memory reduction)
   - Fused decode-compute (no temporary array)
   - Sparse CSR format (skip zeros efficiently)

✓ NET PERFORMANCE GAIN: 1.80x over baseline

This benchmark proves that efficient ternary computation requires
layered optimizations: memory reduction, fused operations, and
sparse formats working together as a complete architecture.
